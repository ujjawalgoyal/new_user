//= ========================= Load Modules Start ===========================

//= ========================= Load External Module =========================

const _ = require("lodash");

//= ========================= Load Internal Module =========================

const appConstants = require("./constants");
const path = require("path");
const fs = require("fs");
const randomstring = require("random-string");
const moment = require("moment");
const config = require("./config").env;
const momentTimezone = require("moment-timezone");
const mongoose = require("mongoose");
const userConstants = require('./user/userConstants');
//= ========================= Load Modules End =============================


//= ========================= Export Module Start ===========================


/**
 * return user home
 * @returns {*}
 */
function getUserHome() {
  return process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;
}

function getNodeEnv() {
  return process.env.NODE_ENV || "local";
}

function getWebUrl() {
  return config.webBaseUrl;
}

function isProdEnv() {
  const env = getNodeEnv();
  return _.includes(["prod", "production"], env);
}

/**
 * returns if email is valid or not
 * @returns {boolean}
 */
function isValidEmail(email) {
  const pattern = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return new RegExp(pattern).test(email);
}

/**
 * returns if zipCode is valid or not (for US only)
 * @returns {boolean}
 */
function createHashSHA256(pass) {
  return sha256(pass);
}

/**
 * returns random number for password
 * @returns {string}
 */
const getRandomPassword = function () {
  return getSHA256(Math.floor((Math.random() * 1000000000000) + 1));
};

let getSHA256 = function (val) {
  return sha256(`${val}password`);
};


function setHeadersForCrossDomainIssues(res) {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Credentials", true);
  res.header("Access-Control-Allow-Headers", "Origin,X-Requested-With,Content-Type,Accept,Authorization, x-custom-token , X-XSRF-TOKEN");
  res.header("Access-Control-Allow-Methods", "POST,GET,PUT,DELETE,OPTIONS");
  return res;
}


function getEmailVerificationLink(token) {
  return `${getWebUrl()}verify/${token}`;
}

function ForgotPasswordLink(token) {
  return `${getWebUrl()}reset/${token}`;
}

function getSortSkipLimitParams({
  pageNo = 1, pageSize = 10, sortOrder = 1, sortBy,
}) {
  const sortSkipLimit = {};
  if (pageSize === "all") {
    console.log("return all listing");
  } else {
    sortSkipLimit.skip = (pageNo - 1) * pageSize;
    // to convert string to int
    sortSkipLimit.limit = 1 * pageSize;
  }
  if (sortBy) {
    sortSkipLimit.sort = { [sortBy]: sortOrder === 1 ? -1 : 1 };
  }
  return sortSkipLimit;
}

function GET_PRJCT_HME_DIR() {
  return path.join(__dirname, "..");
}


/*
 @ calculate the milliseconds
 */
function currentUnixTimeStamp() {
  return Math.floor(Date.now());
}


function createDirectory(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir);
  }
}

const generateExportDataMailBody = (details) => {
  const text = appConstants.MAIL_OPTIONS.EXPORT_DATA_WELCOME_BODY;
  return `<html> <body>${text.replace("#username", details.userName)}</body></html>`;
};

const generateForgotPassMailBody = (details) => {
  const text = appConstants.MAIL_OPTIONS.RESET_PASSWORD;
  const link = getWebUrl() + details.user.token;
  const htmlBody = text.replace("{{username}}", details.user.first_name).replace("{{link}}", link);
  return htmlBody;
};

/**
 *
 * @returns {string}
 * get random 6 digit number
 * FIX ME: remove hard codeing
 * @private
 */
const getRandomOtp = () => {
  // Generate Random Number
  const otp = randomstring({
    length: 4,
    numeric: true,
    letters: false,
    special: false,
    exclude: ["0"],
  });
  console.log(`otp ${JSON.stringify(otp)}`);
  return otp;
};

/* generates referral code
*/
const referralCodeGen = () => {
  const chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZ";
  const strLength = 8;
  let referralcode = "";

  for (let i = 0; i < strLength; i++) {
    const rnum = Math.floor(Math.random() * chars.length);
    referralcode += chars.substring(rnum, rnum + 1);
  }
  return referralcode;
};

/* converts miles to km
*/
const convertMilesToKm = (miles) => {
  const value = parseInt(miles) / 0.62137;
  return value;
};

const removeSpecialCharacter = string => string.replace(/[^0-9]/g, "");

const unixTimeFormatter = date => `${date.getFullYear()}-${(`0${date.getMonth() + 1}`).slice(-2)}-${(`0${date.getDate()}`).slice(-2)}`;


const getNextDates = (unixtime, daysToAdd) => {
  const aryDates = [];
  const startDate = new Date(unixtime * 1000);

  for (let i = 0; i < daysToAdd; i++) {
    const currentDate = new Date();
    currentDate.setDate(startDate.getDate() + i);
    aryDates.push(unixTimeFormatter(currentDate));
  }
  console.log(`array ${JSON.stringify(aryDates)}`);
  return aryDates.map(date => `'${date}'`).join(",");
};

const sanitizeString = string => _.trim(_.toLower(string));
const removeSpaceString = string => _.trim(string);
const getStartOfDayTimestamp = date => Number(moment(date).startOf("day")) / 1000;
const getEndOfDayTimestamp = date => Number(moment(date).endOf("day")) / 1000;
const getNext7DayTimestamp = (date) => {
  const timestamp = moment(date).add(9, "day").format("YYYY-MM-DD");
  return timestamp;
};
const getNextDayTimeStamp = (date, day) => {
  const timestamp = Number(moment(date).add(day, "day"));
  return timestamp;
};
const getUTCDate = params => momentTimezone.tz(params.date, "YYYY-MM-DD", params.time_zone).utc().format("YYYY-MM-DD");
const getStartDayTimestamp = (params) => {
  const date = momentTimezone.tz(params.date, "YYYY-MM-DD", params.time_zone);
  return Number(moment(date).startOf("day").utc()) / 1000;
};

const getEndDayTimestamp = (params) => {
  const date = momentTimezone.tz(params.date, "YYYY-MM-DD", params.time_zone);
  return Number(moment(date).endOf("day").utc()) / 1000;
};

const getDateFromTimestamp = selectedDate => moment(selectedDate).format("YYYY-MM-DD");

function replaceAll(string, replacementArray) {
  return string.replace(/({{\d}})/g, j => replacementArray[j.replace(/{{/, "").replace(/}}/, "")]);
}

const getRegistrationIds = (user) => {
  const registrationIds = [];
  for (let i = 0; i < user.length; i++) {
    const obj = user[i];
    if (obj.push_notification_setting && !_.isEmpty(obj.registration_id)) {
      for (let j = 0; j < obj.registration_id.length; j++) {
        registrationIds.push(obj.registration_id[j]);
      }
    }
  }
  return registrationIds;
};

const startCharacterInUpperCase = str => _.startCase(_.toLower(str));

const getFirstCharacter = (str) => {
  const lastName = str.toUpperCase();
  return `${lastName.substring(0, 1)}.`;
};

function isValidPhone(phone, verifyCountryCode) {
  const reExp = verifyCountryCode ? /^\+\d{6,16}$/ : /^\d{6,16}$/;
  return reExp.test(phone);
}

// Remove special character from tmdb title
const removeSpecialCharacterAndSpace = (string) => {
  let newString = string.replace(/[^a-zA-Z 0-9 ]/g, "");
  // newString = newString.replace(/\s/g, "");
  newString = sanitizeString(newString);
  return newString;
};

// Prepare name
const getName = (user) => {
  let name = "";
  if (user.first_name) {
    name += startCharacterInUpperCase(user.first_name);
  }
  if (user.last_name && name) {
    const lastName = startCharacterInUpperCase(user.last_name);
    name += ` ${lastName}`;
  } else {
    name = startCharacterInUpperCase(user.last_name);
  }
  return name;
};

// Get first and last name from full name
const getFirstNLastNameFromFullName = (string) => {
  const name = {};
  const nameArr = string.split(/\s+/);
  name.first_name = nameArr.slice(0, -1).join(" ");
  name.last_name = nameArr.pop();
  return name;
};

// Method to get timestamp from timezone with date timestamp
const getTimeByTimeZone = (params) => {
  const startDateTimestamp = new Date(momentTimezone.tz(
    params.timestamp,
    params.time_zone,
  ).utc().toDate()).getTime();
  return startDateTimestamp;
};

// Method to get timestamp in UTC from timestamp
const getTimestampInUTCFromTimestamp = (params) => {
  const utcTimeStamp = Number(momentTimezone.tz(
    Number(params.timestamp),
    params.time_zone,
  ).utc());
  return utcTimeStamp;
};

const getUserTimeStamp = (params) => {
  const userUtcCheckInTime = params.date;
  const dateData = getYearMonthFromDate(params.date);
  const checkInTime = {};
  // const startDateTimestamp = Date.UTC(dateData.year, dateData.month, dateData.date);
  const startDateTimestamp = Number(moment().startOf("day").utc());
  let startOfDay = getStartOfDayTimestamp(params.date_time_stamp);
  startOfDay *= 1000;
  checkInTime.startTime = startDateTimestamp + (5 * 60 * 60 * 1000);
  checkInTime.endTime = startDateTimestamp + (23 * 60 * 60 * 1000);
  checkInTime.userUtcTime = new Date(momentTimezone.tz(Number(startOfDay), params.time_zone).utc().toDate()).getTime();
  checkInTime.userUtcCheckInTime = Number(momentTimezone.tz(
    Number(userUtcCheckInTime),
    params.time_zone,
  ).utc());
  return checkInTime;
  // const endDateTimestamp = startDateTimestamp + ((24  60  60 * 1000) - 1);
};

const getYearMonthFromDate = (dateTimeStamp) => {
  const date = new moment(dateTimeStamp);
  date.utcOffset(Number.isFinite(1) ? 0 : parseFloat(0));
  const params = {};
  params.year = date.year();// year
  params.week = date.week(); // week of year
  params.month = date.month(); // month of year (0 to 11)
  params.date = date.date(); // date of month
  return params;
};

// Method to build csv keys model
const buildCsvKeysModel = (params) => {
  const obj = {};
  obj.key = params.Key;
  obj.url = params.Location;
  obj.csv_type = params.csv_type;
  obj.bucket = params.Bucket;
  return obj;
};

const validateTimeZone = (arr, time_zone) => {
  let isValid;
  isValid = arr.some(obj => obj.toLowerCase() === time_zone.toLowerCase());
  return isValid;
};

const sortCsvDataByLineNo = (arr) => {
  arr.sort((a, b) => a["Line No"] - b["Line No"]);
};

const getFileNUserData = (req) => {
  const params = _.pick(req.body, ["is_update"]);
  params.uid = req.user.uid;
  params.file = req.file;
  params.is_update = JSON.parse(params.is_update);
  return params;
};

// Method to build mongo object ids
const buildMongoObjectIds = (ids) => {
  const arr = [];
  for (let i = 0; i < ids.length; i++) {
    arr.push(mongoose.Types.ObjectId(ids[i]));
  }
  return arr;
};

const getUniqueObject = arr => _.uniqBy(arr, "agency_name");

const getRandomAlplhaNumericSting = () => {
  // Generate Random Number
  const string = randomstring({
    length: 12,
    numeric: true,
    letters: true,
    special: false,
  });
  return string;
};

const checkPushType = reward => {


  console.log(reward,"reward");

  if (reward.gained_by == userConstants.GAINED_REWARD_POINT_BY.SIGN_UP.BY) {
    const type = appConstants.PUSH_NOTIFICATION.sign_up_message;
    return type;
  }
  if (reward.gained_by == userConstants.GAINED_REWARD_POINT_BY.COMPLETE_PROFILE.BY) {
    const type = appConstants.PUSH_NOTIFICATION.profile_completion_points;
    return type;
  }
  if (reward.gained_by == userConstants.GAINED_REWARD_POINT_BY.REFERRAL_CODE.BY) {
    const type = appConstants.PUSH_NOTIFICATION.accepted_referral;
    return type;
  }
  if (reward.gained_by == userConstants.GAINED_REWARD_POINT_BY.CHECKIN.BY) {
    const type = appConstants.PUSH_NOTIFICATION.check_in;
    return type;
  }
  if (reward.gained_by == userConstants.GAINED_REWARD_POINT_BY.SOCIAL_SHARE.BY) {
    const type = appConstants.PUSH_NOTIFICATION.social_share;
    return type;
  }
  if (reward.gained_by == userConstants.GAINED_REWARD_POINT_BY.SOCIAL_CONNECT.BY) {
    const type = appConstants.PUSH_NOTIFICATION.social_account_linking;
    console.log(type,"type");
    return type;
  }
};

//= ========================= Export Module Start ===========================

module.exports = {
  getNodeEnv,
  setHeadersForCrossDomainIssues,
  isValidEmail,
  getEmailVerificationLink,
  ForgotPasswordLink,
  getSortSkipLimitParams,
  currentUnixTimeStamp,
  GET_PRJCT_HME_DIR,
  generateExportDataMailBody,
  getRandomOtp,
  generateForgotPassMailBody,
  referralCodeGen,
  convertMilesToKm,
  removeSpecialCharacter,
  unixTimeFormatter,
  getNextDates,
  sanitizeString,
  removeSpaceString,
  getStartOfDayTimestamp,
  getEndOfDayTimestamp,
  getNext7DayTimestamp,
  getNextDayTimeStamp,
  getUTCDate,
  getStartDayTimestamp,
  getEndDayTimestamp,
  getDateFromTimestamp,
  getRegistrationIds,
  replaceAll,
  startCharacterInUpperCase,
  getFirstCharacter,
  isValidPhone,
  removeSpecialCharacterAndSpace,
  getName,
  getFirstNLastNameFromFullName,
  getTimestampInUTCFromTimestamp,
  getUserTimeStamp,
  getYearMonthFromDate,
  buildCsvKeysModel,
  validateTimeZone,
  sortCsvDataByLineNo,
  getFileNUserData,
  buildMongoObjectIds,
  getUniqueObject,
  getRandomAlplhaNumericSting,
  checkPushType,
};

//= ========================= Export Module End===========================

//= ==========================DB Utility==================================
