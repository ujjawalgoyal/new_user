//= ========================= Load Modules Start ===========================

//= ========================= Load external Module =========================

const _ = require("lodash");
//= ========================= Load Internal Module =========================

const appUtils = require("../appUtils");
const appConst = require("../user/userConstants");
const exceptions = require("../customExceptions");
const constants = require("../constants");
const momentTz = require("moment-timezone");
const placeConstants = require("../places/placesConstants");

//= ========================= Load Modules End =============================

const validateUserRegistration = (req, res, next) => {
  const {
    name, email,
    password
  } = _.pick(req.body, ["name", "email",
    "password"]);
  if (_.isEmpty(email)) {
    return next(exceptions.validationError(appConst.MESSAGES.email_is_empty));
  }
  // validate email
  if (!appUtils.isValidEmail(email)) {
    return next(exceptions.validationError(appConst.MESSAGES.invalidEmail));
  }
  if (_.isEmpty(password)) {
    return next(exceptions.validationError(appConst.MESSAGES.password_is_empty));
  }

  if (_.isEmpty(name)) {
    return next(exceptions.validationError(appConst.MESSAGES.nameEmpty));
  }

  return next();
};

const validateOTP = (req, res, next) => {
  const { otp, email } = _.pick(req.body, ["otp", "email"]);
  if (_.isEmpty(otp) || _.isEmpty(email)) {
    return next(exceptions.validationError(appConst.MESSAGES.emailNoEmpty));
  }

  if (req.body.email && !appUtils.isValidEmail(req.body.email)) {
    return next(exceptions.validationError(appConst.MESSAGES.invalidEmail));
  }
  req.body.email = appUtils.sanitizeString(email);
  return next();
};

const resendOTP = (req, res, next) => {
  const { email } = _.pick(req.body, ["email"]);
  if (_.isEmpty(email)) {
    return next(exceptions.validationError(appConst.MESSAGES.emailNoEmpty));
  }

  if (req.body.email && !appUtils.isValidEmail(req.body.email)) {
    return next(exceptions.validationError(appConst.MESSAGES.invalidEmail));
  }
  req.body.email = appUtils.sanitizeString(email);
  return next();
};

const validateBucket = (req, res, next) => {
  const { name } = _.pick(req.body, ["name"]);
  if (_.isEmpty(name)) {
    return next(exceptions.validationError(appConst.MESSAGES.bucketCantEmpty));
  }
  return next();
};

const validateSelectedBucket = (req, res, next) => {
  const { bucket_ids } = _.pick(req.body, ["bucket_ids"]);
  req.body.bucket_ids = JSON.parse(bucket_ids);
  if (_.isEmpty(req.body.bucket_ids)) {
    return next(exceptions.validationError(appConst.MESSAGES.selectedBucketEmpty));
  }
  if (req.body.bucket_ids.length > appConst.SELECTED_MOST_BUCKET) {
    return next(exceptions.validationError(appConst.MESSAGES.atmost4Bucket));
  }
  return next();
};

const getFieldsValueCount = (params) => {
  let count = 0,
    fieldCount = 0;
  for (const property in params) {
    fieldCount++;
    if (params[property]) {
      count++;
    }
  }
  return { count, fieldCount };
};

const buildCountryStateCity = (req) => {
  if (req.body.country) {
    req.body.country_id = req.body.country;
  }
  if (req.body.state) {
    req.body.state_id = req.body.state;
  }
  if (req.body.city) {
    req.body.city_id = req.body.city;
  }
};

const validateCompleteProfile = (req, res, next) => {
  const {
    school, ethnicity, city, state,
    zipcode, country, locality, flat,
  } = _.pick(req.body, ["school", "ethnicity", "city",
    "state", "zipcode", "country", "locality", "flat"]);
  if (!school && !ethnicity && !city && !state && !zipcode && !country && !locality && !flat) {
    return next(exceptions.validationError(appConst.MESSAGES.fieldsCantEmpty));
  }
  buildCountryStateCity(req);
  req.body.fields = getFieldsValueCount(req.body);
  return next();
};

const getEditMoreInfoFields = (params) => {
  let count = 0,
    fieldCount = 0;
  for (const property in params) {
    fieldCount++;
    if (appConst.COMPLETE_PROFILE_FIELDS.indexOf(property) > -1 && params[property]) {
      count++;
    }
  }
  return { count, fieldCount };
};

const validateEditProfile = (req, res, next) => {
  if (req.body.email && !appUtils.isValidEmail(req.body.email)) {
    return next(exceptions.validationError(appConst.MESSAGES.invalidEmail));
  }
  const fields = getEditMoreInfoFields(req.body);
  req.body.profile_already_completed = typeof req.body.profile_completed == "string" ? JSON.parse(req.body.profile_completed) : req.body.profile_completed;
  req.body.profile_completed = typeof req.body.profile_completed == "string" ? JSON.parse(req.body.profile_completed) : req.body.profile_completed;
  console.log(fields.count, "fields");
  console.log(req.body.profile_completed);
  if (fields.count == appConst.COMPLETE_PROFILE_FIELDS_COUNT
    && !req.body.profile_completed) {
    req.body.profile_completed = true;
  }
  buildCountryStateCity(req);
  next();
};

// Validate login creds email & password
const validateCredentials = (req, res, next) => {
  const { email, password } = _.pick(req.body, ["email", "password"]);
  if (_.isEmpty(email)) {
    return next(exceptions.validationError(appConst.MESSAGES.email_is_empty));
  }
  if (_.isEmpty(password)) {
    return next(exceptions.validationError(appConst.MESSAGES.password_is_empty));
  }
  req.body.email = appUtils.sanitizeString(email);
  req.body.password = appUtils.removeSpaceString(password);
  return next();
};

const validateFBLogin = (req, res, next) => {
  const { accessToken } = req.body;
  if (_.isEmpty(accessToken)) {
    return next(exceptions.validationError(appConst.MESSAGES.accessTokenCantEmpty));
  }
  return next();
};

// checks if the password fields are empty or not.
const passwordChangeValidation = (req, res, next) => {
  const { oldPassword, nPassword } = _.pick(req.body, ["oldPassword", "nPassword"]);

  if (_.isEmpty(oldPassword) || _.isEmpty(nPassword)) {
    return next(exceptions.validationError());
  }
  next();
};

/**
 * Validate forgot password
 * @param req
 * @param res
 * @param next
 * @returns {*}
 */

function validateForgotPassword(req, res, next) {
  const { email } = _.pick(req.body, ["email"]);

  // validate email
  if (_.isEmpty(email)) {
    return next(exceptions.validationError(appConst.MESSAGES.invalidEmail));
  }
  req.body.email = appUtils.sanitizeString(email);
  return next();
}

const validateProgramLocation = (req, res, next) => {
  const { latitude, longitude } = _.pick(req.body, ["latitude", "longitude"]);
  if (!latitude || !longitude) {
    return next(exceptions.validationError(programConstants.MESSAGES.programLatLngEmpty));
  }
  req.body.latlng = [parseFloat(longitude), parseFloat(latitude)];
  return next();
};

// Validate program season
const validateSeason = (req, next) => {
  const season = req.body.season;
  if (season && (season != programConstants.SEASON.FALL_SEASON.TYPE
    && season != programConstants.SEASON.SUMMER_SEASON.TYPE
    && season != programConstants.SEASON.WINTER_SEASON.TYPE
    && season != programConstants.SEASON.SPRING_SEASON.TYPE)) {
    return next(exceptions.validationError(programConstants.MESSAGES.programLatLngEmpty));
  }
  req.body.season = parseInt(season);
};

// Method to validate program filter request parameters
const validateProgramFilterParams = (req, res, next) => {
  const {
    latitude, longitude, bucket, season, filter_program_type, radius,
  } = _.pick(req.body, ["latitude", "longitude", "bucket", "season",
    "filter_program_type", "radius"]);
  let is_filter = false;
  if ((latitude && longitude) || !_.isEmpty(bucket) || season || filter_program_type || radius) {
    req.body.is_filter = is_filter = true;
  }
  if (!is_filter) {
    return next();
  }
  if (longitude && latitude) {
    req.body.latlng = [parseFloat(longitude), parseFloat(latitude)];
  }
  validateSeason(req);
  // if (filter_program_type) {
  //   req.body.filter_program_type = JSON.parse(filter_program_type);
  // }
  if (radius) {
    req.body.radius = parseFloat(radius);
  }
  return next();
};

// Method to validate pagination request
const validatePagination = (req, res, next) => {
  const {
    timestamp, limit, program_type, premium_type,
  } = _.pick(req.body, ["limit", "timestamp", "program_type",
    "premium_type"]);
  if (timestamp == undefined) {
    req.body.timestamp = constants.PAGINATION.SKIP;
  } else {
    req.body.timestamp = parseInt(timestamp);
  }
  if (limit && limit > constants.PAGINATION.LIMIT) {
    req.body.limit = constants.PAGINATION.LIMIT;
  } else {
    req.body.limit = parseInt(limit);
  }
  if (program_type) {
    req.body.program_type = parseInt(program_type);
  }
  if (premium_type) {
    req.body.premium_type = parseInt(premium_type);
  }
  return next();
};

const validateFavProgram = (req, res, next) => {
  const { programId } = _.pick(req.body, ["programId"]);
  // validate program id
  if (_.isEmpty(programId)) {
    return next(exceptions.validationError(programConstants.MESSAGES.programIdEmpty));
  }
  req.body.isFav = typeof req.body.isFav === Boolean ? req.body.isFav : JSON.parse(req.body.isFav);
  return next();
};


const validateChangeSetting = (req, res, next) => {
  const { settingFor, settingValue } = _.pick(req.body, ["settingFor", "settingValue"]);
  // validate setting for key
  if (_.isEmpty(settingFor)) {
    return next(exceptions.validationError(appConst.MESSAGES.settingForEmpty));
  }
  if (_.isEmpty(settingValue)) {
    return next(exceptions.validationError(appConst.MESSAGES.settingValueEmpty));
  }
  req.body.settingValue = typeof req.body.settingValue === Boolean ? req.body.settingValue : JSON.parse(req.body.settingValue);
  return next();
};


const validateProgramId = async (req, res, next) => {
  const { programId } = _.pick(req.params, ["programId"]);
  // validate programId
  if (_.isEmpty(programId)) {
    return next(exceptions.validationError(programConstants.MESSAGES.programIdEmpty));
  }
  // validation for checkin

  // if (_.isEmpty(time_zone)) {
  //   return next(exceptions.validationError(programConstants.MESSAGES.timeZoneEmpty));
  // }

  // if (_.isEmpty(date)) {
  //   return next(exceptions.validationError(programConstants.MESSAGES.timeStampEmpty));
  // }

  // let validTimeZone = await appUtils.validateTimeZone(momentTz.tz.names(), time_zone);

  // if (!validTimeZone) {
  //   return next(exceptions.validationError(programConstants.MESSAGES.invalidTimeZone));
  // }

  // validation for checin ends

  return next();
};

const validateStaticPageData = (req, res, next) => {
  const { page_name, page_content } = _.pick(req.body, ["page_name", "page_content"]);
  // validate page name
  if (_.isEmpty(page_name)) {
    return next(exceptions.validationError(appConst.MESSAGES.pagenameEmpty));
  }

  if (_.isEmpty(page_content)) {
    return next(exceptions.validationError(appConst.MESSAGES.pageContentEmpty));
  }
  return next();
};

const validateGetStaticPageData = (req, res, next) => {
  const { page_name } = _.pick(req.params, ["page_name"]);
  // validate page name
  if (_.isEmpty(page_name)) {
    return next(exceptions.validationError(appConst.MESSAGES.pagenameEmpty));
  }
  return next();
};

const validateOccurence = (req, res, next) => {
  const { occurence } = _.pick(req.body, ["occurence"]);
  // validate page name
  if (_.isEmpty(occurence)) {
    return next(exceptions.validationError(programConstants.MESSAGES.programOccurenceCantEmpty));
  }
  const index = adminConstants.OCCURENCE.indexOf(occurence);
  if (index <= -1) {
    return next(exceptions.validationError(programConstants.MESSAGES.invalidProgramOccurence));
  }
  req.body.created_by = req.user.uid;
  req.body.updated_by = req.user.uid;
  return next();
};

const validateCreateProgram = (req, res, next) => {
  const {
    start_time, end_time, occurence_type, latitude, longitude, gender,
  } = _.pick(req.body, ["start_date",
    "end_date", "start_time", "end_time", "occurence_type", "latitude", "longitude", "gender"]);
  if (!latitude || !longitude) {
    return next(exceptions.validationError(programConstants.MESSAGES.programLatLngEmpty));
  }
  if (start_time) {
    req.body.start_time = parseInt(start_time);
  }
  if (end_time) {
    req.body.end_time = parseInt(end_time);
  }
  if (!occurence_type) {
    return next(exceptions.validationError(programConstants.MESSAGES.invalidProgramOccurence));
  }
  // Occurence type date and in season type do'nt consider time
  if (occurence_type == programConstants.PROGRAM_CREATION_TYPE.DATE) {
    // Full day
    if (start_time == end_time) {
      req.body.timestamp = start_time;
      req.body.start_time = Number(appUtils.getTimestampInUTCFromTimestamp(req.body))
        + programConstants.PROGRAM_DURATION.FROM;
      req.body.timestamp = end_time;
      req.body.end_time = Number(appUtils.getTimestampInUTCFromTimestamp(req.body))
        + programConstants.PROGRAM_DURATION.TO;
    } else if (start_time && end_time) {
      req.body.timestamp = start_time;
      req.body.start_time = appUtils.getTimestampInUTCFromTimestamp(req.body);
      req.body.timestamp = end_time;
      req.body.end_time = appUtils.getTimestampInUTCFromTimestamp(req.body);
    }
  }
  return next();
};

const validateCheckIn = (req, res, next) => {
  const {
    programId, latitude, longitude, time_zone, date,
  } = _.pick(req.body, ["programId", "latitude", "longitude", "time_zone", "date"]);
  const params = _.pick(req.body, ["date", "time_zone"]);
  params.date = parseFloat(params.date);
  params.date_time_stamp = params.date;
  // validate program id
  if (_.isEmpty(programId)) {
    return next(exceptions.validationError(programConstants.MESSAGES.programIdEmpty));
  }

  if (!latitude || !longitude) {
    return next(exceptions.validationError(programConstants.MESSAGES.programLatLngEmpty));
  }

  if (_.isEmpty(time_zone)) {
    return next(exceptions.validationError(programConstants.MESSAGES.timeZoneEmpty));
  }

  if (!date) {
    return next(exceptions.validationError(programConstants.MESSAGES.timeStampEmpty));
  }

  const validTimeZone = appUtils.validateTimeZone(momentTz.tz.names(), time_zone);
  console.log("validateTimeZone", validTimeZone);
  if (!validTimeZone) {
    return next(exceptions.validationError(programConstants.MESSAGES.invalidTimeZone));
  }
  req.body.latlng = [parseFloat(longitude), parseFloat(latitude)];
  const checkInTime = appUtils.getUserTimeStamp(params);
  const currentTime = appUtils.currentUnixTimeStamp();
  req.body.userUtcTime = checkInTime.userUtcTime;
  req.body.userUtcCheckInTime = checkInTime.userUtcCheckInTime;
  const time = checkInTime.userUtcCheckInTime;

  console.log(checkInTime, "checkInTime");
  console.log(time, "time");

  /*params.date = params.date + (5 * 60 * 60 * 1000 + 30 * 60 * 1000);*/
  var offset = require("get-timezone-offset")(time_zone, params.date);
  const timeT = params.date - (offset * 60 * 1000);
  console.log("offset", offset)
  console.log(params.date, "date");

  console.log(timeT, "timeT");

  if (timeT < checkInTime.startTime || timeT > checkInTime.endTime) {
    return next(exceptions.validationError(programConstants.MESSAGES.invalidCheckInTime));
  }
  return next();
};
// Method to validate fav program request
const validateFavList = (req, res, next) => {
  const {
    timestamp, limit,
  } = _.pick(req.body, ["limit", "timestamp"]);
  if (timestamp == undefined) {
    req.body.timestamp = constants.PAGINATION.SKIP;
  } else {
    req.body.timestamp = parseInt(timestamp);
  }
  if (limit && limit > constants.PAGINATION.LIMIT) {
    req.body.limit = constants.PAGINATION.LIMIT;
  } else {
    req.body.limit = parseInt(limit);
  }
  return next();
};

// Method to validate program like request
const validateProgramLike = (req, res, next) => {
  const { programId, is_like } = _.pick(req.body, ["programId", "is_like"]);
  // validate program id
  if (_.isEmpty(programId)) {
    return next(exceptions.validationError(programConstants.MESSAGES.programIdEmpty));
  }
  req.body.is_like = typeof req.body.is_like ===
    Boolean ? req.body.is_like : JSON.parse(req.body.is_like);
  return next();
};

const validateSocialConnectReqParams = (req, res, next) => {
  const {
    twit, linkedin, connect_by_twit, connect_by_linkedin, connect_by_inst, inst,
  } = _.pick(req.body, ["twit", "linkedin", "connect_by_twit", "connect_by_linkedin", "connect_by_inst", "inst"]);
  if (connect_by_twit !== undefined) {
    req.body.connect_by_twit = typeof req.body.connect_by_twit ===
      Boolean ? req.body.connect_by_twit : JSON.parse(req.body.connect_by_twit);
  }
  if (connect_by_linkedin !== undefined) {
    req.body.connect_by_linkedin = typeof req.body.connect_by_linkedin ===
      Boolean ? req.body.connect_by_linkedin : JSON.parse(req.body.connect_by_linkedin);
  }
  if (connect_by_inst !== undefined) {
    req.body.connect_by_inst = typeof req.body.connect_by_inst ===
      Boolean ? req.body.connect_by_inst : JSON.parse(req.body.connect_by_inst);
  }
  if (req.body.connect_by_twit) {
    if (_.isEmpty(twit)) {
      return next(exceptions.validationError(socialConnectShareConstants.MESSAGES.cantEmptyTwitOauthToken));
    }
    req.body.twit = JSON.parse(req.body.twit);
  }
  if (req.body.connect_by_linkedin) {
    if (_.isEmpty(linkedin)) {
      return next(exceptions.validationError(socialConnectShareConstants.MESSAGES.cantEmptyLinkedinOauthToken));
    }
    req.body.linkedin = JSON.parse(req.body.linkedin);
  }
  if (req.body.connect_by_inst) {
    if (_.isEmpty(inst)) {
      return next(exceptions.validationError(socialConnectShareConstants.MESSAGES.cantEmptyInstOauthToken));
    }
    req.body.inst = JSON.parse(req.body.inst);
  }
};

// Method to validate social connect
const validateSocialConnect = (req, res, next) => {
  const {
    connect_by_twit, connect_by_linkedin, connect_by_inst,
  } = _.pick(req.body, ["connect_by_twit", "connect_by_linkedin", "connect_by_inst"]);
  if (connect_by_twit === undefined &&
    connect_by_linkedin === undefined && connect_by_inst === undefined) {
    return next(exceptions.validationError(socialConnectShareConstants.MESSAGES.socialConnectAccountCantBeEmpty));
  }
  validateSocialConnectReqParams(req, res, next);
  return next();
};

// Method to validate social share
const validateSocialShare = (req, res, next) => {
  const {
    share_on, twit, linkedin,
  } = _.pick(req.body, ["share_on", "twit", "linkedin"]);
  if (_.isEmpty(share_on)) {
    return next(exceptions.validationError(socialConnectShareConstants.MESSAGES.socialConnectAccountCantBeEmpty));
  }
  req.body.share_on = JSON.parse(share_on);
  if (req.body.share_on.indexOf(constants.SOCIAL_SHARE_ON.TWITTER) > -1) {
    if (_.isEmpty(twit)) {
      return next(exceptions.validationError(socialConnectShareConstants.MESSAGES.cantEmptyTwitOauthToken));
    }
    req.body.twit = JSON.parse(req.body.twit);
    req.body.connect_by_twit = true;
  }
  if (req.body.share_on.indexOf(constants.SOCIAL_SHARE_ON.LINKEDIN) > -1) {
    /*if (_.isEmpty(linkedin)) {
      return next(exceptions.validationError(socialConnectShareConstants.MESSAGES.cantEmptyLinkedinOauthToken));
    }*/
    req.body.linkedin = JSON.parse(req.body.linkedin);
    req.body.connect_by_linkedin = true;
  }
  return next();
};

// Method to validate instagram share
const validateInstaShare = (req, res, next) => {
  const {
    share_insta
  } = _.pick(req.body, ["share_insta"]);
  if (_.isEmpty(share_insta)) {
    return next(exceptions.validationError(socialConnectShareConstants.MESSAGES.socialConnectAccountCantBeEmpty));
  }
  req.body.share_on = JSON.parse(share_insta);
  if (req.body.share_on.indexOf(constants.SOCIAL_SHARE_ON.INSTAGRAM) < 0) {
    return next(exceptions.validationError(socialConnectShareConstants.MESSAGES.socialConnectAccountCantBeEmpty));
  }
  return next();
};

const validateSearchUser = (req, res, next) => {
  const {
    phone_no
  } = _.pick(req.body, ["phone_no"]);
  if (_.isEmpty(phone_no)) {
    return next(exceptions.validationError(appConst.MESSAGES.phoneNoEmpty));
  }
  return next();
};

const validateMakeChild = (req, res, next) => {
  const {
    user_id
  } = _.pick(req.body, ["user_id"]);
  if (_.isEmpty(user_id)) {
    return next(exceptions.validationError(appConst.MESSAGES.userIdEmpty));
  }
  return next();
};

const validateAcceptRejectRequest = (req, res, next) => {
  const {
    request_id, senderId, request_status
  } = _.pick(req.body, ["request_id", "senderId", "request_status"]);
  if (_.isEmpty(request_id)) {
    return next(exceptions.validationError(appConst.MESSAGES.requestIdEmpty));
  }
  if (_.isEmpty(senderId)) {
    return next(exceptions.validationError(appConst.MESSAGES.senderIdEmpty));
  }
  if (_.isEmpty(request_status)) {
    return next(exceptions.validationError(appConst.MESSAGES.requestStatusEmpty));
  }
  const req_status = parseInt(request_status);
  if (req_status != constants.REQUEST_STATUS.ACCEPTED && req_status != constants.REQUEST_STATUS.REJECTED) {
    return next(exceptions.validationError(appConst.MESSAGES.invalidRequestStatus));
  }
  req.body.request_status = req_status;
  return next();
};

const validateAddChildOrParent = (req, res, next) => {
  const {
    first_name, last_name, email, phone_no, gender, dob } = _.pick(req.body, ["first_name", "last_name", "email",
      "phone_no", "gender", "dob"]);
  if (_.isEmpty(email)) {
    return next(exceptions.validationError(appConst.MESSAGES.email_is_empty));
  }
  // validate email
  if (!appUtils.isValidEmail(email)) {
    return next(exceptions.validationError(appConst.MESSAGES.invalidEmail));
  }
  if (_.isEmpty(first_name)) {
    return next(exceptions.validationError(appConst.MESSAGES.firstNameEmpty));
  }
  if (_.isEmpty(last_name)) {
    return next(exceptions.validationError(appConst.MESSAGES.lastNameEmpty));
  }
  if (_.isEmpty(phone_no)) {
    return next(exceptions.validationError(appConst.MESSAGES.phoneNoEmpty));
  }
  if (!gender) {
    return next(exceptions.validationError(appConst.MESSAGES.genderEmpty));
  }
  if (req.user.role == appConst.ROLE.STUDENT) {
    req.body.role = appConst.ROLE.PARENT;
  }
  if (req.user.role == appConst.ROLE.PARENT) {
    req.body.role = appConst.ROLE.STUDENT;
  }
  if (_.isEmpty(dob) && req.body.role == appConst.ROLE.STUDENT) {
    return next(exceptions.validationError(appConst.MESSAGES.dobEmpty));
  }
  req.body.phone_no = appUtils.removeSpecialCharacter(phone_no);
  req.body.login_type = appConst.LOGIN_TYPE.NORMAL_LOGIN;
  req.body.status = appConst.USER_STATUS.INACTIVE;
  return next();
};

const validateSetPassword = (req, res, next) => {
  const { id, password } = _.pick(req.body, ["id", "password"]);
  if (_.isEmpty(id)) {
    return next(exceptions.validationError(appConst.MESSAGES.userIdEmpty));
  }
  if (_.isEmpty(password)) {
    return next(exceptions.validationError(appConst.MESSAGES.password_is_empty));
  }
  return next();
};

const validateRemoveChild = (req, res, next) => {
  const { id } = _.pick(req.body, ["id"]);
  if (_.isEmpty(id)) {
    return next(exceptions.validationError(appConst.MESSAGES.userIdEmpty));
  }
  return next();
};

const validateDistributePoint = (req, res, next) => {
  const { point, user_id } = _.pick(req.body, ["point", "user_id"]);

  if (_.isEmpty(user_id)) {
    return next(exceptions.validationError(appConst.MESSAGES.receiverIdEmpty));
  }
  if (!point) {
    console.log("err")
    return next(exceptions.validationError(appConst.MESSAGES.pointsEmpty));
  }
  if (point <= 0) {
    return next(exceptions.validationError(appConst.MESSAGES.zeroPointNotAllowed));
  }

  if (point % 1 != 0) {
    return next(exceptions.validationError(appConst.MESSAGES.decimalPointNotAllowed));
  }
  return next();
};

const validatePageNo = (req, res, next) => {
  const { page, page_size } = _.pick(req.query, ["page", "page_size"]);
  if (page <= 0 || page_size <= 0) {
    return next(exceptions.validationError(appConst.MESSAGES.zeroPagetNotAllowed));
  }

  return next();
};


const validateCreatePlace = (req, res, next) => {
  const { title, tag_line, description, email, phone_no, location, category_ids } = _.pick(req.body, ["title", "tag_line", "description", "email", "phone_no", "location", "category_ids"]);

  if (_.isEmpty(title)) {
    return next(exceptions.validationError(placeConstants.MESSAGES.title_empty));
  }
  if (_.isEmpty(tag_line)) {
    return next(exceptions.validationError(placeConstants.MESSAGES.tag_line_empty));
  }
  if (_.isEmpty(description)) {
    return next(exceptions.validationError(placeConstants.MESSAGES.description_empty));
  }
  if (_.isEmpty(email)) {
    return next(exceptions.validationError(placeConstants.MESSAGES.email_empty));
  }

  if (_.isEmpty(location)) {
    return next(exceptions.validationError(placeConstants.MESSAGES.location_empty));
  }

  if (_.isEmpty(category_ids) || !category_ids.length) {
    return next(exceptions.validationError(placeConstants.MESSAGES.category_empty));
  }

  // validate email
  if (!appUtils.isValidEmail(email)) {
    return next(exceptions.validationError(appConst.MESSAGES.invalidEmail));
  }

  if (!_.isEmpty(phone_no)) {
    req.body.phone_no = appUtils.removeSpecialCharacter(phone_no);
  }

  return next();
};
//= ========================= Export Module Start ===========================

module.exports = {
  validateUserRegistration,
  validateOTP,
  resendOTP,
  validateBucket,
  validateSelectedBucket,
  validateCompleteProfile,
  validateEditProfile,
  validateCredentials,
  validateFBLogin,
  passwordChangeValidation,
  validateForgotPassword,
  validateProgramLocation,
  validatePagination,
  validateFavProgram,
  validateChangeSetting,
  validateProgramId,
  validateStaticPageData,
  validateGetStaticPageData,
  validateOccurence,
  validateCreateProgram,
  validateCheckIn,
  validateFavList,
  validateProgramLike,
  validateProgramFilterParams,
  validateSocialConnect,
  validateSocialShare,
  validateInstaShare,
  validateSearchUser,
  validateMakeChild,
  validateAcceptRejectRequest,
  validateAddChildOrParent,
  validateSetPassword,
  validateRemoveChild,
  validateDistributePoint,
  validatePageNo,
  validateCreatePlace
};

//= ========================= Export module end ==================================
